// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: service/lerobot/v1/lerobot.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LeRobotServiceClient is the client API for LeRobotService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LeRobotServiceClient interface {
	// StartRecording begins a new recording session for the specified dataset.
	StartRecording(ctx context.Context, in *StartRecordingRequest, opts ...grpc.CallOption) (*StartRecordingResponse, error)
	// StopRecording ends the current recording session and saves the data.
	StopRecording(ctx context.Context, in *StopRecordingRequest, opts ...grpc.CallOption) (*StopRecordingResponse, error)
	// RecordEpisode records a single episode with the specified parameters.
	RecordEpisode(ctx context.Context, in *RecordEpisodeRequest, opts ...grpc.CallOption) (*RecordEpisodeResponse, error)
	// ReplayEpisode plays back a previously recorded episode.
	ReplayEpisode(ctx context.Context, in *ReplayEpisodeRequest, opts ...grpc.CallOption) (*ReplayEpisodeResponse, error)
	// StartTeleoperation begins a teleoperation session with the specified device.
	StartTeleoperation(ctx context.Context, in *StartTeleoperationRequest, opts ...grpc.CallOption) (*StartTeleoperationResponse, error)
	// StopTeleoperation ends the current teleoperation session.
	StopTeleoperation(ctx context.Context, in *StopTeleoperationRequest, opts ...grpc.CallOption) (*StopTeleoperationResponse, error)
	// LoadPolicy loads a policy from a HuggingFace repo or local path.
	LoadPolicy(ctx context.Context, in *LoadPolicyRequest, opts ...grpc.CallOption) (*LoadPolicyResponse, error)
	// RunPolicyEpisode executes a loaded policy for a single episode.
	RunPolicyEpisode(ctx context.Context, in *RunPolicyEpisodeRequest, opts ...grpc.CallOption) (*RunPolicyEpisodeResponse, error)
}

type leRobotServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLeRobotServiceClient(cc grpc.ClientConnInterface) LeRobotServiceClient {
	return &leRobotServiceClient{cc}
}

func (c *leRobotServiceClient) StartRecording(ctx context.Context, in *StartRecordingRequest, opts ...grpc.CallOption) (*StartRecordingResponse, error) {
	out := new(StartRecordingResponse)
	err := c.cc.Invoke(ctx, "/viam.service.lerobot.v1.LeRobotService/StartRecording", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leRobotServiceClient) StopRecording(ctx context.Context, in *StopRecordingRequest, opts ...grpc.CallOption) (*StopRecordingResponse, error) {
	out := new(StopRecordingResponse)
	err := c.cc.Invoke(ctx, "/viam.service.lerobot.v1.LeRobotService/StopRecording", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leRobotServiceClient) RecordEpisode(ctx context.Context, in *RecordEpisodeRequest, opts ...grpc.CallOption) (*RecordEpisodeResponse, error) {
	out := new(RecordEpisodeResponse)
	err := c.cc.Invoke(ctx, "/viam.service.lerobot.v1.LeRobotService/RecordEpisode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leRobotServiceClient) ReplayEpisode(ctx context.Context, in *ReplayEpisodeRequest, opts ...grpc.CallOption) (*ReplayEpisodeResponse, error) {
	out := new(ReplayEpisodeResponse)
	err := c.cc.Invoke(ctx, "/viam.service.lerobot.v1.LeRobotService/ReplayEpisode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leRobotServiceClient) StartTeleoperation(ctx context.Context, in *StartTeleoperationRequest, opts ...grpc.CallOption) (*StartTeleoperationResponse, error) {
	out := new(StartTeleoperationResponse)
	err := c.cc.Invoke(ctx, "/viam.service.lerobot.v1.LeRobotService/StartTeleoperation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leRobotServiceClient) StopTeleoperation(ctx context.Context, in *StopTeleoperationRequest, opts ...grpc.CallOption) (*StopTeleoperationResponse, error) {
	out := new(StopTeleoperationResponse)
	err := c.cc.Invoke(ctx, "/viam.service.lerobot.v1.LeRobotService/StopTeleoperation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leRobotServiceClient) LoadPolicy(ctx context.Context, in *LoadPolicyRequest, opts ...grpc.CallOption) (*LoadPolicyResponse, error) {
	out := new(LoadPolicyResponse)
	err := c.cc.Invoke(ctx, "/viam.service.lerobot.v1.LeRobotService/LoadPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leRobotServiceClient) RunPolicyEpisode(ctx context.Context, in *RunPolicyEpisodeRequest, opts ...grpc.CallOption) (*RunPolicyEpisodeResponse, error) {
	out := new(RunPolicyEpisodeResponse)
	err := c.cc.Invoke(ctx, "/viam.service.lerobot.v1.LeRobotService/RunPolicyEpisode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeRobotServiceServer is the server API for LeRobotService service.
// All implementations must embed UnimplementedLeRobotServiceServer
// for forward compatibility
type LeRobotServiceServer interface {
	// StartRecording begins a new recording session for the specified dataset.
	StartRecording(context.Context, *StartRecordingRequest) (*StartRecordingResponse, error)
	// StopRecording ends the current recording session and saves the data.
	StopRecording(context.Context, *StopRecordingRequest) (*StopRecordingResponse, error)
	// RecordEpisode records a single episode with the specified parameters.
	RecordEpisode(context.Context, *RecordEpisodeRequest) (*RecordEpisodeResponse, error)
	// ReplayEpisode plays back a previously recorded episode.
	ReplayEpisode(context.Context, *ReplayEpisodeRequest) (*ReplayEpisodeResponse, error)
	// StartTeleoperation begins a teleoperation session with the specified device.
	StartTeleoperation(context.Context, *StartTeleoperationRequest) (*StartTeleoperationResponse, error)
	// StopTeleoperation ends the current teleoperation session.
	StopTeleoperation(context.Context, *StopTeleoperationRequest) (*StopTeleoperationResponse, error)
	// LoadPolicy loads a policy from a HuggingFace repo or local path.
	LoadPolicy(context.Context, *LoadPolicyRequest) (*LoadPolicyResponse, error)
	// RunPolicyEpisode executes a loaded policy for a single episode.
	RunPolicyEpisode(context.Context, *RunPolicyEpisodeRequest) (*RunPolicyEpisodeResponse, error)
	mustEmbedUnimplementedLeRobotServiceServer()
}

// UnimplementedLeRobotServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLeRobotServiceServer struct {
}

func (UnimplementedLeRobotServiceServer) StartRecording(context.Context, *StartRecordingRequest) (*StartRecordingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRecording not implemented")
}
func (UnimplementedLeRobotServiceServer) StopRecording(context.Context, *StopRecordingRequest) (*StopRecordingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopRecording not implemented")
}
func (UnimplementedLeRobotServiceServer) RecordEpisode(context.Context, *RecordEpisodeRequest) (*RecordEpisodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordEpisode not implemented")
}
func (UnimplementedLeRobotServiceServer) ReplayEpisode(context.Context, *ReplayEpisodeRequest) (*ReplayEpisodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplayEpisode not implemented")
}
func (UnimplementedLeRobotServiceServer) StartTeleoperation(context.Context, *StartTeleoperationRequest) (*StartTeleoperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTeleoperation not implemented")
}
func (UnimplementedLeRobotServiceServer) StopTeleoperation(context.Context, *StopTeleoperationRequest) (*StopTeleoperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopTeleoperation not implemented")
}
func (UnimplementedLeRobotServiceServer) LoadPolicy(context.Context, *LoadPolicyRequest) (*LoadPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadPolicy not implemented")
}
func (UnimplementedLeRobotServiceServer) RunPolicyEpisode(context.Context, *RunPolicyEpisodeRequest) (*RunPolicyEpisodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunPolicyEpisode not implemented")
}
func (UnimplementedLeRobotServiceServer) mustEmbedUnimplementedLeRobotServiceServer() {}

// UnsafeLeRobotServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LeRobotServiceServer will
// result in compilation errors.
type UnsafeLeRobotServiceServer interface {
	mustEmbedUnimplementedLeRobotServiceServer()
}

func RegisterLeRobotServiceServer(s grpc.ServiceRegistrar, srv LeRobotServiceServer) {
	s.RegisterService(&LeRobotService_ServiceDesc, srv)
}

func _LeRobotService_StartRecording_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRecordingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeRobotServiceServer).StartRecording(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/viam.service.lerobot.v1.LeRobotService/StartRecording",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeRobotServiceServer).StartRecording(ctx, req.(*StartRecordingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeRobotService_StopRecording_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRecordingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeRobotServiceServer).StopRecording(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/viam.service.lerobot.v1.LeRobotService/StopRecording",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeRobotServiceServer).StopRecording(ctx, req.(*StopRecordingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeRobotService_RecordEpisode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordEpisodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeRobotServiceServer).RecordEpisode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/viam.service.lerobot.v1.LeRobotService/RecordEpisode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeRobotServiceServer).RecordEpisode(ctx, req.(*RecordEpisodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeRobotService_ReplayEpisode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplayEpisodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeRobotServiceServer).ReplayEpisode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/viam.service.lerobot.v1.LeRobotService/ReplayEpisode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeRobotServiceServer).ReplayEpisode(ctx, req.(*ReplayEpisodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeRobotService_StartTeleoperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTeleoperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeRobotServiceServer).StartTeleoperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/viam.service.lerobot.v1.LeRobotService/StartTeleoperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeRobotServiceServer).StartTeleoperation(ctx, req.(*StartTeleoperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeRobotService_StopTeleoperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopTeleoperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeRobotServiceServer).StopTeleoperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/viam.service.lerobot.v1.LeRobotService/StopTeleoperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeRobotServiceServer).StopTeleoperation(ctx, req.(*StopTeleoperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeRobotService_LoadPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeRobotServiceServer).LoadPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/viam.service.lerobot.v1.LeRobotService/LoadPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeRobotServiceServer).LoadPolicy(ctx, req.(*LoadPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeRobotService_RunPolicyEpisode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunPolicyEpisodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeRobotServiceServer).RunPolicyEpisode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/viam.service.lerobot.v1.LeRobotService/RunPolicyEpisode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeRobotServiceServer).RunPolicyEpisode(ctx, req.(*RunPolicyEpisodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LeRobotService_ServiceDesc is the grpc.ServiceDesc for LeRobotService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LeRobotService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "viam.service.lerobot.v1.LeRobotService",
	HandlerType: (*LeRobotServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartRecording",
			Handler:    _LeRobotService_StartRecording_Handler,
		},
		{
			MethodName: "StopRecording",
			Handler:    _LeRobotService_StopRecording_Handler,
		},
		{
			MethodName: "RecordEpisode",
			Handler:    _LeRobotService_RecordEpisode_Handler,
		},
		{
			MethodName: "ReplayEpisode",
			Handler:    _LeRobotService_ReplayEpisode_Handler,
		},
		{
			MethodName: "StartTeleoperation",
			Handler:    _LeRobotService_StartTeleoperation_Handler,
		},
		{
			MethodName: "StopTeleoperation",
			Handler:    _LeRobotService_StopTeleoperation_Handler,
		},
		{
			MethodName: "LoadPolicy",
			Handler:    _LeRobotService_LoadPolicy_Handler,
		},
		{
			MethodName: "RunPolicyEpisode",
			Handler:    _LeRobotService_RunPolicyEpisode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/lerobot/v1/lerobot.proto",
}
