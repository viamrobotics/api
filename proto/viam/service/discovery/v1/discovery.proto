syntax = "proto3";

package viam.service.discovery.v1;

import "common/v1/common.proto";
import "google/api/annotations.proto";
import "google/protobuf/struct.proto";

option go_package = "go.viam.com/api/service/discovey/v1";
option java_package = "com.viam.service.discovery.v1";

service DiscoveryService {
  // DiscoverResources returns the list of all discovered viam resources connected to the viam-server machine.
  rpc DiscoverResources(DiscoverResourcesRequest) returns (DiscoverResourcesResponse) {
    option (google.api.http) = {get: "/viam/api/v1/service/{name}/discovery"};
  }

  // DoCommand sends/receives arbitrary commands
  rpc DoCommand(common.v1.DoCommandRequest) returns (common.v1.DoCommandResponse) {
    option (google.api.http) = {post: "/viam/api/v1/service/discovery/{name}/do_command"};
  }
}

message DiscoverResourcesRequest {
  // name of the discover service
  string name = 1;
  // Additional arguments to the method
  google.protobuf.Struct extra = 99;
}

message DiscoverResourcesResponse {
  // list of ComponentConfigs that describe the components found by a discover service.
  repeated ComponentConfig discoveries = 1;
}

message ComponentConfig {
  string name = 1;
  string namespace = 2; // deprecated; use api
  string type = 3; // deprecated; use api
  string model = 4;
  Frame frame = 5;
  repeated string depends_on = 6;
  repeated ResourceLevelServiceConfig service_configs = 7;
  google.protobuf.Struct attributes = 8;
  string api = 9;
  LogConfiguration log_configuration = 10;
}

// A ResourceLevelServiceConfig describes component or remote configuration for a service.
message ResourceLevelServiceConfig {
  string type = 1;
  // TODO(adam): Should this be move to a structured type as defined in the typescript frontend.
  google.protobuf.Struct attributes = 2;
}

message Frame {
  string parent = 1;
  Translation translation = 2;
  Orientation orientation = 3;
  common.v1.Geometry geometry = 4;
}

message LogConfiguration {
  string level = 1;
}

message Translation {
  double x = 1;
  double y = 2;
  double z = 3;
}

message Orientation {
  message NoOrientation {}

  // OrientationVector containing ox, oy, oz, theta represents an orientation vector
  // Structured similarly to an angle axis, an orientation vector works differently. Rather than representing an orientation
  // with an arbitrary axis and a rotation around it from an origin, an orientation vector represents orientation
  // such that the ox/oy/oz components represent the point on the cartesian unit sphere at which your end effector is pointing
  // from the origin, and that unit vector forms an axis around which theta rotates. This means that incrementing/decrementing
  // theta will perform an in-line rotation of the end effector.
  // Theta is defined as rotation between two planes: the plane defined by the origin, the point (0,0,1), and the rx,ry,rz
  // point, and the plane defined by the origin, the rx,ry,rz point, and the new local Z axis. So if theta is kept at
  // zero as the north/south pole is circled, the Roll will correct itself to remain in-line.
  message OrientationVectorRadians {
    double theta = 1;
    double x = 2;
    double y = 3;
    double z = 4;
  }

  // OrientationVectorDegrees is the orientation vector between two objects, but expressed in degrees rather than radians.
  // Because protobuf Pose is in degrees, this is necessary.
  message OrientationVectorDegrees {
    double theta = 1;
    double x = 2;
    double y = 3;
    double z = 4;
  }

  // EulerAngles are three angles (in radians) used to represent the rotation of an object in 3D Euclidean space
  // The Tait–Bryan angle formalism is used, with rotations around three distinct axes in the z-y′-x″ sequence.
  message EulerAngles {
    double roll = 1;
    double pitch = 2;
    double yaw = 3;
  }

  // See here for a thorough explanation: https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation
  // Basic explanation: Imagine a 3d cartesian grid centered at 0,0,0, and a sphere of radius 1 centered at
  // that same point. An orientation can be expressed by first specifying an axis, i.e. a line from the origin
  // to a point on that sphere, represented by (rx, ry, rz), and a rotation around that axis, theta.
  // These four numbers can be used as-is (R4), or they can be converted to R3, where theta is multiplied by each of
  // the unit sphere components to give a vector whose length is theta and whose direction is the original axis.
  // AxisAngles represents an R4 axis angle.
  message AxisAngles {
    double theta = 1;
    double x = 2;
    double y = 3;
    double z = 4;
  }

  // Quaternion is a float64 precision quaternion.
  message Quaternion {
    double w = 1;
    double x = 2;
    double y = 3;
    double z = 4;
  }

  oneof type {
    NoOrientation no_orientation = 1;
    OrientationVectorRadians vector_radians = 2;
    OrientationVectorDegrees vector_degrees = 3;
    EulerAngles euler_angles = 4;
    AxisAngles axis_angles = 5;
    Quaternion quaternion = 6;
  }
}
